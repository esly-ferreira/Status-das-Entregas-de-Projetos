html:
<canvas id="c"></canvas>
<script id="vertexShader" type="x-shader/x-vertex">
  varying vec2 vUv;

  void main()	{
    vUv = uv;
    gl_Position = vec4( position, 1.0 );
  }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
  // https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram
  varying vec2 vUv;
  uniform float time;
  uniform int stripe_count;
  uniform float stripe_size;
  uniform float noise_zoom;
  
  //	Simplex 3D Noise 
  //	by Ian McEwan, Ashima Arts
  vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
  vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

  float snoise(vec3 v){ 
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

    // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    //  x0 = x0 - 0. + 0.0 * C 
    vec3 x1 = x0 - i1 + 1.0 * C.xxx;
    vec3 x2 = x0 - i2 + 2.0 * C.xxx;
    vec3 x3 = x0 - 1. + 3.0 * C.xxx;

    // Permutations
    i = mod(i, 289.0 ); 
    vec4 p = permute( permute( permute( 
               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

    // Gradients
    // ( N*N points uniformly over a square, mapped onto an octahedron.)
    float n_ = 1.0/7.0; // N=7
    vec3  ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

    //Normalise gradients
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                  dot(p2,x2), dot(p3,x3) ) );
  }
  
  //https://github.com/Jam3/glsl-hsl2rgb
  float hue2rgb(float f1, float f2, float hue) {
    if (hue < 0.0)
      hue += 1.0;
    else if (hue > 1.0)
      hue -= 1.0;
    float res;
    if ((6.0 * hue) < 1.0)
      res = f1 + (f2 - f1) * 6.0 * hue;
    else if ((2.0 * hue) < 1.0)
      res = f2;
    else if ((3.0 * hue) < 2.0)
      res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;
    else
      res = f1;
    return res;
  }

  vec3 hsl2rgb(vec3 hsl) {
    vec3 rgb;

    if (hsl.y == 0.0) {
      rgb = vec3(hsl.z); // Luminance
    } else {
      float f2;

      if (hsl.z < 0.5)
        f2 = hsl.z * (1.0 + hsl.y);
      else
        f2 = hsl.z + hsl.y - hsl.y * hsl.z;

      float f1 = 2.0 * hsl.z - f2;

      rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));
      rgb.g = hue2rgb(f1, f2, hsl.x);
      rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));
    }   
    return rgb;
  }

  vec3 hsl2rgb(float h, float s, float l) {
    return hsl2rgb(vec3(h, s, l));
  }
  
  // size must be between 0.0 and 1.0
  // #define ANGLE 0.9
  #define HUE_OFFSET 0.04
  #define SAT_OFFSET 0.0
  #define LIGHT_OFFSET 0.03
  
  void main()	{
    //BG
    float hueAmplitude = 0.06;
    float startHue = hueAmplitude + 0.4 + (time / 10.0);
    
    startHue = mod(startHue, 1.0) - hueAmplitude;
    
    float noise = snoise(vec3(vUv.xy * (1.0 + ((1.0 - noise_zoom) * 9.0)), time));
    vec3 hsl = vec3(startHue + (noise * hueAmplitude), 0.1, 0.4);
    
    //stripes
    float stripeWidth = (1.0 / float(stripe_count)) * stripe_size;
    for (int i = 0; i < 100; i++) {
      // hack to use dynamic count as loop ceiling... https://stackoverflow.com/a/39298265/1257868
      if (i < stripe_count) {
        float xPos = float(i) / float(stripe_count) - (time);
        
        // float rotation = (sin(vUv.y + time) + 1.0) / 2.0 * ANGLE;
        // xPos += rotation; // rotate stripes
        
        xPos += noise; // noise
        xPos = mod(xPos, 1.0); // repeat the stripe

        if (vUv.x > (xPos) && vUv.x <= (xPos + stripeWidth)) {
          hsl += vec3(HUE_OFFSET, SAT_OFFSET, LIGHT_OFFSET);
        }

        //finish the lines
        if (xPos > (1.0 - stripeWidth) && xPos <= 1.0 && vUv.x > 0.0 && vUv.x <= stripeWidth - (1.0 - xPos)) {
          hsl += vec3(HUE_OFFSET, SAT_OFFSET, LIGHT_OFFSET);
        }
      }
    }
    
    vec3 col = hsl2rgb(hsl);
    gl_FragColor = vec4(col, 1.0);
  }
</script>

css:
body {
  overflow: hidden;
}

canvas {
  width: 100vw; height: 100vh;
}

Js:
console.clear()

class Utils {
  static randomRange(min, max) {
    return Math.random() * (max - min) + min
  }

  static mapRange (value, inputMin, inputMax, outputMin, outputMax, clamp) {
    if (Math.abs(inputMin - inputMax) < Number.EPSILON) {
      return outputMin
    } else {
      var outVal = ((value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin) + outputMin)
      if (clamp) {
        if (outputMax < outputMin) {
          if (outVal < outputMax) outVal = outputMax
          else if (outVal > outputMin) outVal = outputMin
        } else {
          if (outVal > outputMax) outVal = outputMax
          else if (outVal < outputMin) outVal = outputMin
        }
      }
      return outVal
    }
  }
}

Utils.simplex = new SimplexNoise('seed') 

class App {  
  constructor() {
    this.config = {
      bgColor: '#333',
      speed: 1,
      maxSpeed: 2,

      stripeSize: 0.5,
      stripeCount: 9,

      noiseZoom: 1
    }
    
    this.setUpVars()
    this.setUpListeners()
    this.createScene()
    this.setUpGui()
    this.update()
  }

  createScene() {
    this.canvas = document.getElementById('c')
    this.scene = new THREE.Scene()
    this.camera = new THREE.PerspectiveCamera(75, this.wWidth / this.wHeight, 0.1, 1000)
    this.renderer = new THREE.WebGLRenderer({
      canvas: this.canvas,
      antialias: true
    })
    
    
    //Bg Mesh
    this.uniforms = {
      time: { 
        value: 1.0 
      },
      
	    stripe_count: { 
        value: this.config.stripeCount
      },
      
      stripe_size: {
        value: this.config.stripeSize
      },
      
      noise_zoom: {
        value: this.config.noiseZoom
      }
    }
    this.geometry = new THREE.PlaneBufferGeometry(2, 2)
    this.material = new THREE.ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent
    })
		this.mesh = new THREE.Mesh(this.geometry, this.material)
    this.scene.add(this.mesh)
    
    this.renderer.setClearColor(this.config.bgColor)
    this.renderer.setPixelRatio(window.devicePixelRatio)
    this.renderer.setSize(this.wWidth, this.wHeight)
  }

  setUpGui() {
    const pane = new Tweakpane()
    const folder = pane.addFolder({
      expanded: false,
      title: 'Settings',
    })
    // folder.addInput(this.config, 'bgColor').on('change', () => {
    //   this.renderer.setClearColor(this.config.bgColor)
    // })
    folder.addInput(this.config, 'speed', {
      min: 0.01,
      max: this.config.maxSpeed,
      step: 0.01
    })
    
    folder.addInput(this.config, 'stripeCount', {
      min: 1,
      max: 50,
      step: 1
    }).on('change', value => {
      this.uniforms.stripe_count.value = value
    })
    
    folder.addInput(this.config, 'stripeSize', {
      min: 0.01,
      max: 1,
      step: 0.01
    }).on('change', value => {
      this.uniforms.stripe_size.value = value
    })
    
    folder.addInput(this.config, 'noiseZoom', {
      min: 0.01,
      max: 1,
      step: 0.01
    }).on('change', value => {
      this.uniforms.noise_zoom.value = value
    })
  }
  
  setUpVars() {
    this.wWidth = window.innerWidth
    this.wHeight = window.innerHeight
    this.wCenterX = this.wWidth / 2
    this.wCenterY = this.wHeight / 2
    this.wHypot = Math.hypot(this.wWidth, this.wHeight)
    this.wMin = Math.min(this.wWidth, this.wHeight)
    
    if (this.renderer) {
      this.renderer.setSize(this.wWidth, this.wHeight)
      this.uniforms.resolution = new THREE.Uniform(
        new THREE.Vector2(this.wWidth, this.wHeight)
      )
    }
  }
  
  setUpListeners() {
    window.addEventListener('resize', this.setUpVars.bind(this))
  }
  
  update(timestamp) {
    this.uniforms.time.value = timestamp / (1000 + ((this.config.maxSpeed - this.config.speed) * 9000))
    this.renderer.render(this.scene, this.camera)
    window.requestAnimationFrame(this.update.bind(this))
  }
}

new App()
